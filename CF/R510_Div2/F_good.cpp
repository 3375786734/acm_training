/*
 *idea:在树上进行递归求解,我们只维护一个beautiful set中的深度最大的那一个节点,最为这个set的代表,然后自底向上进行启发式合并.
 *具体的,先找到当前根节点rt孩子中有最多beautiful set的那一个孩子,记为u(只是为了启发式合并),遍历其他的孩子,如果其他孩子的set子集中,可以和其余的某些子集合并的话,我们就和深度最大的那一个合并同时更新当前合并的这个子集的深度,否则当前的根节点就要又加入一个beautiful set,最终得到的就是最优解.
 *
 *注意到上面得到的一定是合法的,下面证明最优性:beautiful set的个数不可能少于这个值了,否则的话,存在两个距离超过k的两个必须被合并,产生矛盾
 *
 *复杂度分析:在每个叶子节点合并的时候,都需要logN时间进行搜索,然后,由于每个叶子启发式合并次数为O(logN)次,因此对于所有的叶子,最终需要O(N log^2 N)次操作.
 *
 *进一步的优化:注意到单调性,如果你可以和depth比较深的合并,也就意味着可以和浅的合并,因此深度深的beautiful set对答案是没有影响的,可以直接去掉,即可以省去multiset的二分查找,保证只有一个元素在multiset中,因此复杂度为O(N log N)
 */
#include <bits/stdc++.h>
using namespace std;
const int maxn=;

int main()
{
	
}

